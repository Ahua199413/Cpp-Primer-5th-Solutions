#### hp = hp2

在此赋值中，右侧运算对象hp2是一个左值，不能匹配移动构造函数，因此rhs将使用拷贝构造函数进行拷贝初始化；而这里使用了拷贝并交换，因此rhs将是hp2的一个副本；swap调用将\*this中原来保存的指针存入rhs中，并将rhs中原来的指针存入\*this中，调用结束后\*this中的指针成员将指向新分配的string——即右侧运算对象中string的一个副本；赋值运算符结束时，rhs被销毁，HasPtr的析构函数被执行，delete了rhs指向的内存——即左侧运算对象原来指向的内存

#### hp = std::move(hp2)

在此赋值中，调用std::move将一个右值引用绑定到hp2上；在此情况下，拷贝构造函数和移动构造函数都是可行的，但实参是右值所以移动构造函数将精确匹配；所以rhs将直接从hp2“窃取”资源（拷贝指针），而不分配任何新内存；swap调用将\*this中原来保存的指针存入rhs中，并将rhs中原来的指针存入\*this中，调用结束后\*this中的指针成员将指向新分配的string——即右侧运算对象中string的一个副本；赋值运算符结束时，rhs被销毁，HasPtr的析构函数被执行，delete了rhs指向的内存——即左侧运算对象原来指向的内存